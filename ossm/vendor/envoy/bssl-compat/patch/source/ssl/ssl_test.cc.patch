--- a/source/ssl/ssl_test.cc
+++ b/source/ssl/ssl_test.cc
@@ -85,13 +85,19 @@
 // static const size_t kTicketKeyLen = 48;
 
 static const VersionParam kAllVersions[] = {
+#ifndef BSSL_COMPAT // OpenSSL 3.0.x no longer supports TLS 1.0 or TLS1.1
     {TLS1_VERSION, VersionParam::is_tls, "TLS1"},
     {TLS1_1_VERSION, VersionParam::is_tls, "TLS1_1"},
+#endif
     {TLS1_2_VERSION, VersionParam::is_tls, "TLS1_2"},
     {TLS1_3_VERSION, VersionParam::is_tls, "TLS1_3"},
+#ifndef BSSL_COMPAT // OpenSSL 3.0.x no longer supports DTLS 1.0
     {DTLS1_VERSION, VersionParam::is_dtls, "DTLS1"},
+#endif
     {DTLS1_2_VERSION, VersionParam::is_dtls, "DTLS1_2"},
+#ifdef DTLS1_3_EXPERIMENTAL_VERSION
     {DTLS1_3_EXPERIMENTAL_VERSION, VersionParam::is_dtls, "DTLS1_3"},
+#endif // DTLS1_3_EXPERIMENTAL_VERSION
 };
 
 // struct ExpectedCipher {
@@ -1169,6 +1175,7 @@
     int auth_nid;
     int prf_nid;
   } kTests[] = {
+#ifdef SSL3_CK_RSA_DES_192_CBC3_SHA
       {
           SSL3_CK_RSA_DES_192_CBC3_SHA,
           "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
@@ -1178,6 +1185,7 @@
           NID_auth_rsa,
           NID_md5_sha1,
       },
+#endif
       {
           TLS1_CK_RSA_WITH_AES_128_SHA,
           "TLS_RSA_WITH_AES_128_CBC_SHA",
@@ -1682,7 +1690,11 @@
     if (client_err != SSL_ERROR_NONE &&
         client_err != SSL_ERROR_WANT_READ &&
         client_err != SSL_ERROR_WANT_WRITE &&
+#ifdef SSL_ERROR_PENDING_TICKET
         client_err != SSL_ERROR_PENDING_TICKET) {
+#else
+        true) {
+#endif
       fprintf(stderr, "Client error: %s\n", SSL_error_description(client_err));
       return false;
     }
@@ -1692,7 +1704,11 @@
     if (server_err != SSL_ERROR_NONE &&
         server_err != SSL_ERROR_WANT_READ &&
         server_err != SSL_ERROR_WANT_WRITE &&
+#ifdef SSL_ERROR_PENDING_TICKET
         server_err != SSL_ERROR_PENDING_TICKET) {
+#else
+        true) {
+#endif
       fprintf(stderr, "Server error: %s\n", SSL_error_description(server_err));
       return false;
     }
@@ -1780,7 +1796,12 @@
     return false;
   }
   if (config.early_data) {
+#ifndef BSSL_COMPAT
     SSL_set_early_data_enabled(client.get(), 1);
+#else
+    std::cout << "WARNING: Skipped SSL_set_early_data_enabled()" << std::endl;
+    return false;
+#endif
   }
   if (config.session) {
     SSL_set_session(client.get(), config.session);
@@ -1790,14 +1811,25 @@
     return false;
   }
   if (!config.verify_hostname.empty()) {
+#ifndef BSSL_COMPAT
     if (!SSL_set1_host(client.get(), config.verify_hostname.c_str())) {
       return false;
     }
     SSL_set_hostflags(client.get(), config.hostflags);
+#else
+    std::cout << "WARNING: Skipped SSL_set1_host() & SSL_set_hostflags()" << std::endl;
+    return false;
+#endif
   }
 
+#ifndef BSSL_COMPAT
   SSL_set_shed_handshake_config(client.get(), shed_handshake_config);
   SSL_set_shed_handshake_config(server.get(), shed_handshake_config);
+#else
+  if(shed_handshake_config) {
+    std::cout << "WARNING: Skipped SSL_set_shed_handshake_config()" << std::endl;
+  }
+#endif
 
   if (!CompleteHandshakes(client.get(), server.get())) {
     return false;
@@ -3410,12 +3442,16 @@
   // However, for historical reasons, the X509 chain includes the leaf on the
   // client, but does not on the server.
   EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(client_.get())), 1u);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
   EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(client_.get())),
             1u);
+#endif
 
   EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(server_.get())), 0u);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
   EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(server_.get())),
             1u);
+#endif
 }
 
 TEST_P(SSLVersionTest, NoPeerCertificate) {
@@ -3428,7 +3464,9 @@
   // Server should not see a peer certificate.
   bssl::UniquePtr<X509> peer(SSL_get_peer_certificate(server_.get()));
   ASSERT_FALSE(peer);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
   ASSERT_FALSE(SSL_get0_peer_certificates(server_.get()));
+#endif
 }
 
 // TEST_P(SSLVersionTest, RetainOnlySHA256OfCerts) {
@@ -3635,11 +3673,13 @@
 #ifdef BSSL_COMPAT
 GTEST_SKIP() << "TODO: Investigate failure on BSSL_COMPAT";
 #endif
+#ifdef DTLS1_3_EXPERIMENTAL_VERSION
   if (version() == DTLS1_3_EXPERIMENTAL_VERSION) {
     // TODO(crbug.com/boringssl/715): Enable the rest of this test for DTLS 1.3
     // once it supports NewSessionTickets.
     return;
   }
+#endif // DTLS1_3_EXPERIMENTAL_VERSION
   static const uint8_t kContext1[] = {1};
   static const uint8_t kContext2[] = {2};
 
@@ -4145,8 +4185,10 @@
       return "DTLSv1";
     case DTLS1_2_VERSION:
       return "DTLSv1.2";
+#ifdef DTLS1_3_EXPERIMENTAL_VERSION
     case DTLS1_3_EXPERIMENTAL_VERSION:
       return "DTLSv1.3";
+#endif // DTLS1_3_EXPERIMENTAL_VERSION
     default:
       return "???";
   }
@@ -4612,11 +4654,13 @@
   bssl::UniquePtr<SSL_SESSION> session =
       CreateClientSession(client_ctx_.get(), server_ctx_.get(), config);
 
+#ifdef DTLS1_3_EXPERIMENTAL_VERSION
   if (version() == DTLS1_3_EXPERIMENTAL_VERSION) {
     // TODO(crbug.com/boringssl/715): Enable the rest of this test for DTLS 1.3
     // once it supports NewSessionTickets.
     return;
   }
+#endif // DTLS1_3_EXPERIMENTAL_VERSION
   // If the client resumes a session with a different name, |SSL_get_servername|
   // must return the new name.
   ASSERT_TRUE(session);
@@ -8059,11 +8103,13 @@
 #ifdef BSSL_COMPAT
 GTEST_SKIP() << "TODO: Investigate failure on BSSL_COMPAT";
 #endif
+#ifdef DTLS1_3_EXPERIMENTAL_VERSION
   if (version() == DTLS1_3_EXPERIMENTAL_VERSION) {
     // TODO(crbug.com/boringssl/715): Enable the rest of this test for DTLS 1.3
     // once it supports NewSessionTickets.
     return;
   }
+#endif // DTLS1_3_EXPERIMENTAL_VERSION
   uint8_t key[48];
   RAND_bytes(key, sizeof(key));
 
