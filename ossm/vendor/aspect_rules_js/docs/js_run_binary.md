<!-- Generated with Stardoc: http://skydoc.bazel.build -->

Runs a js_binary as a build action.

This macro wraps Aspect bazel-lib's run_binary (https://github.com/aspect-build/bazel-lib/blob/main/lib/run_binary.bzl)
and adds attributes and features specific to rules_js's js_binary.

Load this with,

```starlark
load("@aspect_rules_js//js:defs.bzl", "js_run_binary")
```


<a id="js_run_binary"></a>

## js_run_binary

<pre>
js_run_binary(<a href="#js_run_binary-name">name</a>, <a href="#js_run_binary-tool">tool</a>, <a href="#js_run_binary-env">env</a>, <a href="#js_run_binary-srcs">srcs</a>, <a href="#js_run_binary-outs">outs</a>, <a href="#js_run_binary-out_dirs">out_dirs</a>, <a href="#js_run_binary-args">args</a>, <a href="#js_run_binary-chdir">chdir</a>, <a href="#js_run_binary-stdout">stdout</a>, <a href="#js_run_binary-stderr">stderr</a>, <a href="#js_run_binary-exit_code_out">exit_code_out</a>,
              <a href="#js_run_binary-silent_on_success">silent_on_success</a>, <a href="#js_run_binary-use_execroot_entry_point">use_execroot_entry_point</a>, <a href="#js_run_binary-copy_srcs_to_bin">copy_srcs_to_bin</a>,
              <a href="#js_run_binary-include_transitive_sources">include_transitive_sources</a>, <a href="#js_run_binary-include_declarations">include_declarations</a>, <a href="#js_run_binary-include_npm_linked_packages">include_npm_linked_packages</a>,
              <a href="#js_run_binary-log_level">log_level</a>, <a href="#js_run_binary-mnemonic">mnemonic</a>, <a href="#js_run_binary-progress_message">progress_message</a>, <a href="#js_run_binary-execution_requirements">execution_requirements</a>, <a href="#js_run_binary-stamp">stamp</a>, <a href="#js_run_binary-patch_node_fs">patch_node_fs</a>,
              <a href="#js_run_binary-allow_execroot_entry_point_with_no_copy_data_to_bin">allow_execroot_entry_point_with_no_copy_data_to_bin</a>, <a href="#js_run_binary-use_default_shell_env">use_default_shell_env</a>, <a href="#js_run_binary-kwargs">kwargs</a>)
</pre>

Wrapper around @aspect_bazel_lib `run_binary` that adds convenience attributes for using a `js_binary` tool.

This rule does not require Bash `native.genrule`.

The following environment variables are made available to the Node.js runtime based on available Bazel [Make variables](https://bazel.build/reference/be/make-variables#predefined_variables):

* BAZEL_BINDIR: the WORKSPACE-relative bazel bin directory; equivalent to the `$(BINDIR)` Make variable of the `js_run_binary` target
* BAZEL_COMPILATION_MODE: One of `fastbuild`, `dbg`, or `opt` as set by [`--compilation_mode`](https://bazel.build/docs/user-manual#compilation-mode); equivalent to `$(COMPILATION_MODE)` Make variable of the `js_run_binary` target
* BAZEL_TARGET_CPU: the target cpu architecture; equivalent to `$(TARGET_CPU)` Make variable of the `js_run_binary` target

The following environment variables are made available to the Node.js runtime based on the rule context:

* BAZEL_BUILD_FILE_PATH: the WORKSPACE-relative path to the BUILD file of the bazel target being run; equivalent to `ctx.build_file_path` of the `js_run_binary` target's rule context
* BAZEL_PACKAGE: the package of the bazel target being run; equivalent to `ctx.label.package` of the `js_run_binary` target's rule context
* BAZEL_TARGET_NAME: the full label of the bazel target being run; a stringified version of `ctx.label` of the `js_run_binary` target's rule context
* BAZEL_TARGET: the name of the bazel target being run; equivalent to `ctx.label.name` of the  `js_run_binary` target's rule context
* BAZEL_WORKSPACE: the bazel workspace name; equivalent to `ctx.workspace_name` of the `js_run_binary` target's rule context


**PARAMETERS**


| Name  | Description | Default Value |
| :------------- | :------------- | :------------- |
| <a id="js_run_binary-name"></a>name |  Target name   |  none |
| <a id="js_run_binary-tool"></a>tool |  The tool to run in the action.<br><br>Should be a <code>js_binary</code> rule. Use Aspect bazel-lib's run_binary (https://github.com/aspect-build/bazel-lib/blob/main/lib/run_binary.bzl) for other *_binary rule types.   |  none |
| <a id="js_run_binary-env"></a>env |  Environment variables of the action.<br><br>Subject to <code>$(location)</code> and make variable expansion.   |  <code>{}</code> |
| <a id="js_run_binary-srcs"></a>srcs |  Additional inputs of the action.<br><br>These labels are available for <code>$(location)</code> expansion in <code>args</code> and <code>env</code>.   |  <code>[]</code> |
| <a id="js_run_binary-outs"></a>outs |  Output files generated by the action.<br><br>These labels are available for <code>$(location)</code> expansion in <code>args</code> and <code>env</code>.   |  <code>[]</code> |
| <a id="js_run_binary-out_dirs"></a>out_dirs |  Output directories generated by the action.<br><br>These labels are _not_ available for <code>$(location)</code> expansion in <code>args</code> and <code>env</code> since they are not pre-declared labels created via attr.output_list(). Output directories are declared instead by <code>ctx.actions.declare_directory</code>.   |  <code>[]</code> |
| <a id="js_run_binary-args"></a>args |  Command line arguments of the binary.<br><br>Subject to <code>$(location)</code> and make variable expansion.   |  <code>[]</code> |
| <a id="js_run_binary-chdir"></a>chdir |  Working directory to run the build action in.<br><br>This overrides the chdir value if set on the <code>js_binary</code> tool target.<br><br>By default, <code>js_binary</code> tools run in the root of the output tree. For more context on why, please read the aspect_rules_js README https://github.com/aspect-build/rules_js/tree/dbb5af0d2a9a2bb50e4cf4a96dbc582b27567155#running-nodejs-programs.<br><br>To run in the directory containing the js_run_binary in the output tree, use <code>chdir = package_name()</code> (or if you're in a macro, use <code>native.package_name()</code>).<br><br>WARNING: this will affect other paths passed to the program, either as arguments or in configuration files, which are workspace-relative.<br><br>You may need <code>../../</code> segments to re-relativize such paths to the new working directory.   |  <code>None</code> |
| <a id="js_run_binary-stdout"></a>stdout |  Output file to capture the stdout of the binary.<br><br>This can later be used as an input to another target subject to the same semantics as <code>outs</code>.<br><br>If the binary creates outputs and these are declared, they must still be created.   |  <code>None</code> |
| <a id="js_run_binary-stderr"></a>stderr |  Output file to capture the stderr of the binary to.<br><br>This can later be used as an input to another target subject to the same semantics as <code>outs</code>.<br><br>If the binary creates outputs and these are declared, they must still be created.   |  <code>None</code> |
| <a id="js_run_binary-exit_code_out"></a>exit_code_out |  Output file to capture the exit code of the binary to.<br><br>This can later be used as an input to another target subject to the same semantics as <code>outs</code>. Note that setting this will force the binary to exit 0.<br><br>If the binary creates outputs and these are declared, they must still be created.   |  <code>None</code> |
| <a id="js_run_binary-silent_on_success"></a>silent_on_success |  produce no output on stdout nor stderr when program exits with status code 0.<br><br>This makes node binaries match the expected bazel paradigm.   |  <code>True</code> |
| <a id="js_run_binary-use_execroot_entry_point"></a>use_execroot_entry_point |  Use the <code>entry_point</code> script of the <code>js_binary</code> <code>tool</code> that is in the execroot output tree instead of the copy that is in runfiles.<br><br>Runfiles of <code>tool</code> are all hoisted to <code>srcs</code> of the underlying <code>run_binary</code> so they are included as execroot inputs to the action.<br><br>Using the entry point script that is in the execroot output tree means that there will be no conflicting runfiles <code>node_modules</code> in the node_modules resolution path which can confuse npm packages such as next and react that don't like being resolved in multiple node_modules trees. This more closely emulates the environment that tools such as Next.js see when they are run outside of Bazel.<br><br>When True, the <code>js_binary</code> tool must have <code>copy_data_to_bin</code> set to True (the default) so that all data files needed by the binary are available in the execroot output tree. This requirement can be turned off with by setting <code>allow_execroot_entry_point_with_no_copy_data_to_bin</code> to True.   |  <code>True</code> |
| <a id="js_run_binary-copy_srcs_to_bin"></a>copy_srcs_to_bin |  When True, all srcs files are copied to the output tree that are not already there.   |  <code>True</code> |
| <a id="js_run_binary-include_transitive_sources"></a>include_transitive_sources |  see <code>js_filegroup</code> documentation   |  <code>True</code> |
| <a id="js_run_binary-include_declarations"></a>include_declarations |  see <code>js_filegroup</code> documentation   |  <code>False</code> |
| <a id="js_run_binary-include_npm_linked_packages"></a>include_npm_linked_packages |  see <code>js_filegroup</code> documentation   |  <code>True</code> |
| <a id="js_run_binary-log_level"></a>log_level |  Set the logging level of the <code>js_binary</code> tool.<br><br>This overrides the log level set on the <code>js_binary</code> tool target.   |  <code>None</code> |
| <a id="js_run_binary-mnemonic"></a>mnemonic |  A one-word description of the action, for example, CppCompile or GoLink.   |  <code>"JsRunBinary"</code> |
| <a id="js_run_binary-progress_message"></a>progress_message |  Progress message to show to the user during the build, for example, "Compiling foo.cc to create foo.o". The message may contain %{label}, %{input}, or %{output} patterns, which are substituted with label string, first input, or output's path, respectively. Prefer to use patterns instead of static strings, because the former are more efficient.   |  <code>None</code> |
| <a id="js_run_binary-execution_requirements"></a>execution_requirements |  Information for scheduling the action.<br><br>For example,<br><br><pre><code> execution_requirements = {     "no-cache": "1", }, </code></pre><br><br>See https://docs.bazel.build/versions/main/be/common-definitions.html#common.tags for useful keys.   |  <code>None</code> |
| <a id="js_run_binary-stamp"></a>stamp |  Whether to include build status files as inputs to the tool. Possible values:<br><br>- <code>stamp = 0 (default)</code>: Never include build status files as inputs to the tool.     This gives good build result caching.     Most tools don't use the status files, so including them in <code>--stamp</code> builds makes those     builds have many needless cache misses.     (Note: this default is different from most rules with an integer-typed <code>stamp</code> attribute.) - <code>stamp = 1</code>: Always include build status files as inputs to the tool, even in     [--nostamp](https://docs.bazel.build/versions/main/user-manual.html#flag--stamp) builds.     This setting should be avoided, since it is non-deterministic.     It potentially causes remote cache misses for the target and     any downstream actions that depend on the result. - <code>stamp = -1</code>: Inclusion of build status files as inputs is controlled by the     [--[no]stamp](https://docs.bazel.build/versions/main/user-manual.html#flag--stamp) flag.     Stamped targets are not rebuilt unless their dependencies change.<br><br>Default value is <code>0</code> since the majority of js_run_binary targets in a build graph typically do not use build status files and including them for all js_run_binary actions whenever <code>--stamp</code> is set would result in invalidating the entire graph and would prevent cache hits. Stamping is typically done in terminal targets when building release artifacts and stamp should typically be set explicitly in these targets to <code>-1</code> so it is enabled when the <code>--stamp</code> flag is set.<br><br>When stamping is enabled, an additional two environment variables will be set for the action:     - <code>BAZEL_STABLE_STATUS_FILE</code>     - <code>BAZEL_VOLATILE_STATUS_FILE</code><br><br>These files can be read and parsed by the action, for example to pass some values to a bundler.   |  <code>0</code> |
| <a id="js_run_binary-patch_node_fs"></a>patch_node_fs |  Patch the to Node.js <code>fs</code> API (https://nodejs.org/api/fs.html) for this node program to prevent the program from following symlinks out of the execroot, runfiles and the sandbox.<br><br>When enabled, <code>js_binary</code> patches the Node.js sync and async <code>fs</code> API functions <code>lstat</code>, <code>readlink</code>, <code>realpath</code>, <code>readdir</code> and <code>opendir</code> so that the node program being run cannot resolve symlinks out of the execroot and the runfiles tree. When in the sandbox, these patches prevent the program being run from resolving symlinks out of the sandbox.<br><br>When disabled, node programs can leave the execroot, runfiles and sandbox by following symlinks which can lead to non-hermetic behavior.   |  <code>True</code> |
| <a id="js_run_binary-allow_execroot_entry_point_with_no_copy_data_to_bin"></a>allow_execroot_entry_point_with_no_copy_data_to_bin |  Turn off validation that the <code>js_binary</code> tool has <code>copy_data_to_bin</code> set to True when <code>use_execroot_entry_point</code> is set to True.<br><br>See <code>use_execroot_entry_point</code> doc for more info.   |  <code>False</code> |
| <a id="js_run_binary-use_default_shell_env"></a>use_default_shell_env |  If set, passed to the underlying run_binary.<br><br>May introduce non-determinism when True; use with care! See e.g. https://github.com/bazelbuild/bazel/issues/4912<br><br>Requires a minimum of aspect_bazel_lib v1.40.3 or v2.4.2.<br><br>Refer to https://bazel.build/rules/lib/builtins/actions#run for more details.   |  <code>None</code> |
| <a id="js_run_binary-kwargs"></a>kwargs |  Additional arguments   |  none |


