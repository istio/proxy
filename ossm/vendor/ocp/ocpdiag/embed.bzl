# Copyright 2022 Google LLC
#
# Use of this source code is governed by an MIT-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT.

"""Starlark definitions for build rules embed data files directly into code libraries."""

def cc_data_library(
        name,
        data,
        cc_namespace,
        var_name,
        visibility = None,
        flatten = False):
    """Define a data library containing a set of embedded files.

    A cc_library will be generated by this rule that exports an array containing
    embedded data from all of the given data files. This library will have a
    header named ${name}.h and a source file named ${name}.cc.

    By default all the data files will be embedded using their path relative to
    the package name. If the flatten argument is true then their names will be
    reduced to their base names.

    Args:
      name: The name of the cc_library that will contain the embedded data.
      data: A list of data files to embed into the cc_library.
      cc_namespace: The C++ namespace to wrap the generated variable into.
      var_name: The name of the C++ variable used to access the data.
      visibility: The visibility of the generated cc_library.
      flatten: If true, embed all the data file names using just their basename.
    """

    # Wrap the data files to embed in a filegroup. We do this to avoid issues with
    # filenames that would otherwise get interpreted as Make variables (e.g. $metadata).
    # Including those files directly in the genrule srcs and using $(SRCS) would have
    # that problem, but routing them through a filegroup avoids that problem.
    native.filegroup(
        name = name + "__data_filegroup",
        srcs = data,
    )

    # Run the cc_embed tool to generate a header and code file embedding all the data
    # files. Note that we strip four prefixes from the file paths: first the BINDIR and
    # GENDIR which ensures that every file is represented with its path relative to the
    # workspace root, then the repository name to cover the case where this project is
    # being built as an external dependency, and finally the package name to change the
    # path to being relative to the local package instead of the global workspace path.
    # This stripping is redundant in cases where we specify --flatten but for simplicity
    # we just always pass in the stripping args.
    flatten_arg = "--flatten" if flatten else ""
    external_prefix = "external/{}".format(native.repository_name().lstrip("@"))
    native.genrule(
        name = name + "__generator",
        srcs = [":" + name + "__data_filegroup"],
        outs = [name + ".cc", name + ".h"],
        cmd = ("$(location @com_google_ecclesia//ecclesia/lib/file:cc_embed) " +
               "--output_name=%s --output_dir=\"$(@D)\" --namespace=%s --variable_name=%s " +
               "--strip_prefixes=$(BINDIR),$(GENDIR),%s,%s %s " +
               "$(locations :%s__data_filegroup)") %
              (
                  name,
                  cc_namespace,
                  var_name,
                  external_prefix,
                  native.package_name(),
                  flatten_arg,
                  name,
              ),
        exec_tools = ["@com_google_ecclesia//ecclesia/lib/file:cc_embed"],
    )

    # Encapsulate the code an header files into a cc_library.
    native.cc_library(
        name = name,
        srcs = [name + ".cc"],
        hdrs = [name + ".h"],
        deps = ["@com_google_ecclesia//ecclesia/lib/file:cc_embed_interface"],
        visibility = visibility,
    )
