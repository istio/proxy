// Copyright 2022 Google LLC
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

#ifndef OCPDIAG_CORE_RESULTS_OCP_DATA_MODEL_INPUT_MODEL_H_
#define OCPDIAG_CORE_RESULTS_OCP_DATA_MODEL_INPUT_MODEL_H_

#include <optional>
#include <string>
#include <tuple>
#include <vector>

#include "google/protobuf/util/time_util.h"  // Included to properly import the timeval struct
#include "ocpdiag/core/results/data_model/variant.h"

namespace ocpdiag::results {

// The structs in this file allow users to provide input to the results library.
// They correspond to the OCP output spec - note that any missing inputs (such
// as unique IDs) will be generated by the library in compliance with the spec.
// See https://github.com/opencomputeproject/ocp-diag-core/tree/main/json_spec
// for detailed documentation.

constexpr int kMajorSchemaVersion = 2;
constexpr int kMinorSchemaVersion = 0;

enum class ValidatorType {
  kUnspecified = 0,
  kEqual = 1,
  kNotEqual = 2,
  kLessThan = 3,
  kLessThanOrEqual = 4,
  kGreaterThan = 5,
  kGreaterThanOrEqual = 6,
  kRegexMatch = 7,
  kRegexNoMatch = 8,
  kInSet = 9,
  kNotInSet = 10,
};

struct Validator {
  ValidatorType type;          // Required
  std::vector<Variant> value;  // Required, TODO(b/262605576) Update this to use
                               // std::variant when Google moves to C++20
  std::string name;

  auto tie() const { return std::tie(type, value, name); }

  bool operator==(const Validator& rhs) const { return tie() == rhs.tie(); }
};

class DutInfo;

struct HardwareInfo {
  std::string name;  // Required
  std::string computer_system;
  std::string location;
  std::string odata_id;
  std::string part_number;
  std::string serial_number;
  std::string manager;
  std::string manufacturer;
  std::string manufacturer_part_number;
  std::string part_type;
  std::string version;
  std::string revision;
};

class RegisteredHardwareInfo {
 public:
  RegisteredHardwareInfo() = default;

  const std::string& id() const { return id_; }

 private:
  friend class DutInfo;
  std::string id_;
};

enum class SoftwareType {
  kUnspecified = 0,
  kFirmware = 1,
  kSystem = 2,
  kApplication = 3
};

struct SoftwareInfo {
  std::string name;  // Required
  std::string computer_system;
  std::string version;
  std::string revision;
  SoftwareType software_type;
};

class RegisteredSoftwareInfo {
 public:
  RegisteredSoftwareInfo() = default;

  const std::string& id() const { return id_; }

 private:
  friend class DutInfo;
  std::string id_;
};

struct PlatformInfo {
  std::string info;  // Required

  bool operator==(const PlatformInfo& rhs) const { return info == rhs.info; }
};

enum class SubcomponentType {
  kUnspecified = 0,
  kAsic = 1,
  kAsicSubsystem = 2,
  kBus = 3,
  kFunction = 4,
  kConnector = 5,
};

struct Subcomponent {
  std::string name;  // Required
  SubcomponentType type;
  std::string location;
  std::string version;
  std::string revision;

  auto tie() const { return std::tie(name, type, location, version, revision); }

  bool operator==(const Subcomponent& rhs) const { return tie() == rhs.tie(); }
};

struct MeasurementSeriesStart {
  std::string name;  // Required
  std::string unit;
  std::optional<RegisteredHardwareInfo> hardware_info;
  std::optional<Subcomponent> subcomponent;
  std::vector<Validator> validators;
  std::string metadata_json;
};

struct MeasurementSeriesElement {
  Variant value;  // Required
  std::optional<timeval> timestamp;
  std::string metadata_json;
};

struct Measurement {
  std::string name;  // Required
  std::string unit;
  std::optional<RegisteredHardwareInfo> hardware_info;
  std::optional<Subcomponent> subcomponent;
  std::vector<Validator> validators;
  Variant value;  // Required
  std::string metadata_json;
};

enum class DiagnosisType {
  kUnknown = 0,
  kPass = 1,
  kFail = 2,
};

struct Diagnosis {
  std::string verdict;  // Required
  DiagnosisType type;   // Required
  std::string message;
  std::optional<RegisteredHardwareInfo> hardware_info;
  std::optional<Subcomponent> subcomponent;
};

struct Error {
  std::string symptom;  // Required
  std::string message;
  std::vector<RegisteredSoftwareInfo> software_infos;
};

// The numbers in the enum should match the Abseil LogSeverity enum where they
// overlap so one way conversion to Abseil LogSeverity is possible.
enum class LogSeverity {
  kInfo = 0,
  kWarning = 1,
  kError = 2,
  kFatal = 3,
  kDebug = 4,
};

struct Log {
  LogSeverity severity;  // Required
  std::string message;   // Required

  auto tie() const { return std::tie(severity, message); }

  bool operator==(const Log& rhs) const { return tie() == rhs.tie(); }
};

struct File {
  std::string display_name;  // Required
  std::string uri;           // Required
  bool is_snapshot;          // Required
  std::string description;
  std::string content_type;

  auto tie() const {
    return std::tie(display_name, uri, is_snapshot, description, content_type);
  }

  bool operator==(const File& rhs) const { return tie() == rhs.tie(); }
};

struct TestRunStart {
  std::string name;             // Required
  std::string version;          // Required
  std::string command_line;     // Required
  std::string parameters_json;  // Required
  std::string metadata_json;
};

struct Extension {
  std::string name;          // Required
  std::string content_json;  // Required

  auto tie() const { return std::tie(name, content_json); }

  bool operator==(const Extension& rhs) const { return tie() == rhs.tie(); }
};

}  // namespace ocpdiag::results

#endif  // OCPDIAG_CORE_RESULTS_OCP_DATA_MODEL_INPUT_MODEL_H_
