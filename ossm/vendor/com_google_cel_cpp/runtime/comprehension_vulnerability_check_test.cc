// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "runtime/comprehension_vulnerability_check.h"

#include <utility>

#include "cel/expr/syntax.pb.h"
#include "absl/status/status.h"
#include "absl/strings/string_view.h"
#include "extensions/protobuf/runtime_adapter.h"
#include "internal/testing.h"
#include "internal/testing_descriptor_pool.h"
#include "parser/parser.h"
#include "runtime/runtime_builder.h"
#include "runtime/runtime_options.h"
#include "runtime/standard_runtime_builder_factory.h"
#include "google/protobuf/text_format.h"

namespace cel {
namespace {

using ::absl_testing::IsOk;
using ::absl_testing::StatusIs;
using ::cel::extensions::ProtobufRuntimeAdapter;
using ::cel::expr::ParsedExpr;
using ::google::api::expr::parser::Parse;
using ::google::protobuf::TextFormat;
using ::testing::HasSubstr;

constexpr absl::string_view kVulnerableExpr = R"pb(
  expr {
    id: 1
    comprehension_expr {
      iter_var: "unused"
      accu_var: "accu"
      result {
        id: 2
        ident_expr { name: "accu" }
      }
      accu_init {
        id: 11
        list_expr {
          elements {
            id: 12
            const_expr { int64_value: 0 }
          }
        }
      }
      loop_condition {
        id: 13
        const_expr { bool_value: true }
      }
      loop_step {
        id: 3
        call_expr {
          function: "_+_"
          args {
            id: 4
            ident_expr { name: "accu" }
          }
          args {
            id: 5
            ident_expr { name: "accu" }
          }
        }
      }
      iter_range {
        id: 6
        list_expr {
          elements {
            id: 7
            const_expr { int64_value: 0 }
          }
          elements {
            id: 8
            const_expr { int64_value: 0 }
          }
          elements {
            id: 9
            const_expr { int64_value: 0 }
          }
          elements {
            id: 10
            const_expr { int64_value: 0 }
          }
        }
      }
    }
  }
)pb";

TEST(ComprehensionVulnerabilityCheck, EnabledVulnerable) {
  RuntimeOptions runtime_options;
  ASSERT_OK_AND_ASSIGN(
      RuntimeBuilder builder,
      CreateStandardRuntimeBuilder(internal::GetTestingDescriptorPool(),
                                   runtime_options));
  ASSERT_OK(EnableComprehensionVulnerabiltyCheck(builder));

  ASSERT_OK_AND_ASSIGN(auto runtime, std::move(builder).Build());

  ParsedExpr expr;
  ASSERT_TRUE(TextFormat::ParseFromString(kVulnerableExpr, &expr));

  EXPECT_THAT(
      ProtobufRuntimeAdapter::CreateProgram(*runtime, expr),
      StatusIs(
          absl::StatusCode::kInvalidArgument,
          HasSubstr("Comprehension contains memory exhaustion vulnerability")));
}

TEST(ComprehensionVulnerabilityCheck, EnabledNotVulnerable) {
  RuntimeOptions runtime_options;
  ASSERT_OK_AND_ASSIGN(
      RuntimeBuilder builder,
      CreateStandardRuntimeBuilder(internal::GetTestingDescriptorPool(),
                                   runtime_options));
  ASSERT_OK(EnableComprehensionVulnerabiltyCheck(builder));

  ASSERT_OK_AND_ASSIGN(auto runtime, std::move(builder).Build());

  ASSERT_OK_AND_ASSIGN(ParsedExpr expr, Parse("[0, 0, 0, 0].map(x, x + 1)"));

  EXPECT_THAT(ProtobufRuntimeAdapter::CreateProgram(*runtime, expr), IsOk());
}

TEST(ComprehensionVulnerabilityCheck, DisabledVulnerable) {
  RuntimeOptions runtime_options;
  ASSERT_OK_AND_ASSIGN(
      RuntimeBuilder builder,
      CreateStandardRuntimeBuilder(internal::GetTestingDescriptorPool(),
                                   runtime_options));

  ASSERT_OK_AND_ASSIGN(auto runtime, std::move(builder).Build());

  ParsedExpr expr;
  ASSERT_TRUE(TextFormat::ParseFromString(kVulnerableExpr, &expr));

  EXPECT_THAT(ProtobufRuntimeAdapter::CreateProgram(*runtime, expr), IsOk());
}

}  // namespace
}  // namespace cel
